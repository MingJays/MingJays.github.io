<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png"><link rel="icon" type="image/png" href="/img/favicon_128px.ico"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="description" content=""><meta name="author" content="MingJays"><meta name="keywords" content=""><title>Java虚拟机——内存区域 - Mind The Gap</title><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/9.18.1/styles/monokai-sublime.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_fmb4a04yx8h.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_ijqayz9ro8k.css"><link rel="stylesheet" href="/css/main.css"><meta name="generator" content="Hexo 4.2.0"></head><body><header style="height:80vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>Mind The Gap</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> 友链</a></li><li class="nav-item" id="search-btn"><a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i class="iconfont icon-search"></i>&nbsp;&nbsp;</a></li></ul></div></div></nav><div class="view intro-2" id="background" parallax="true" style="background:url(/img/article_bg.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,0)"><div class="container text-center white-text fadeInUp"><span class="h2" id="subtitle"></span><div class="mt-3 post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2020-05-07 21:38">星期四, 五月 7日 2020, 9:38 晚上</time></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 4k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 41 分钟</span></div></div></div></div></div></header><main><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="container nopadding-md" id="board-ctn"><div class="py-5" id="board"><div class="post-content mx-auto" id="post"><article class="markdown-body"><div class="note note-primary"><p>阅读周志明老师的《深入理解Java虚拟机》第2章：Java内存区域与内存溢出异常，做读书笔记</p></div><h3 id="1-运行时数据区域"><a href="#1-运行时数据区域" class="headerlink" title="1.运行时数据区域"></a>1.运行时数据区域</h3><p>Java虚拟机在执行Java程序的过程中，会把它所管理的内存划分为不同的数据区域。</p><p><img src="/img/article/004_Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" srcset="/img/loading.gif" alt=""></p><h4 id="1-1程序计数器"><a href="#1-1程序计数器" class="headerlink" title="1.1程序计数器"></a>1.1程序计数器</h4><p>程序计数器是一块较小的内存空间，可以看作当前线程所执行的字节码的行号指示器，字节码解释器通过改变程序计数器的值来选取下一条执行的字节码指令，每条线程有独立的程序计数器，程序计数器是“<strong>线程私有</strong>”。线程执行Java方法时，程序计数器记录字节码指令地址，线程执行Native方法时，程序计数器的值为空（Undefined）。<strong>唯一一个在虚拟机规范中没有规定任何OutOfMemoryError情况的区域</strong>。</p><h4 id="1-2Java虚拟机栈"><a href="#1-2Java虚拟机栈" class="headerlink" title="1.2Java虚拟机栈"></a>1.2Java虚拟机栈</h4><p>Java虚拟机栈也是<strong>线程私有</strong>，生命周期与线程相同。描述Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。方法从调用到完成的过程，对应着栈帧在虚拟机栈中入栈到出栈的过程。经常有人把Java内存粗糙的分为堆内存（Heap）和栈内存（Stack），栈内存指的就是虚拟机栈，或者说虚拟机栈中局部变量表部分。</p><p>局部变量表存放编译期可知的基本数据类型、对象引用和returnAddress类型。</p><blockquote><p>基本数据类型：boolean、byte、char、short、int、float、long、double<br>对象引用：reference类型，不等同对象本身，是指向对象起始地址的引用指针，或代表对象的句柄<br>returnAddress类型：指向了一条字节码指令的地址<br>64位长度的long和double占用2个局部变量空间（Slot），其余的数据类型占用1个。<strong>局部变量表所需的内存空间在编译器期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小</strong>。</p></blockquote><p>Java虚拟机栈规定了两种异常情况，StackOverflowError异常和OutOfMemoryError异常</p><blockquote><p>StackOverflowError：如果线程请求的栈深度大于虚拟机所允许的深度，则抛出该异常<br>OutOfMemoryError：如果虚拟机在动态扩展时无法申请到足够的内存，就会抛出该异常</p></blockquote><h4 id="1-3本地方法栈"><a href="#1-3本地方法栈" class="headerlink" title="1.3本地方法栈"></a>1.3本地方法栈</h4><p>本地方法栈与Java虚拟机栈是相似的，Java虚拟机栈为虚拟机执行java 方法（也就是字节码）服务，而本地方法栈为虚拟机使用Native方法服务。Sun的HotSpot虚拟机把本地方法栈和Java虚拟机栈合二为一。</p><h4 id="1-4Java堆"><a href="#1-4Java堆" class="headerlink" title="1.4Java堆"></a>1.4Java堆</h4><p>Java堆被<strong>所有线程共享</strong>，几乎所有的对象实例以及数组都是在堆上分配，随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将导致一些变化，所有对象都在堆上分配变得不是那么“绝对”。</p><p>Java堆是垃圾收集器管理的主要区域，从内存回收的角度来看，由于现在收集器基本都采用<strong>分代收集算法</strong>，所有Java堆可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。</p><p>Java堆可以处于物理上不连续的内存空间中，只要逻辑连续即可，再实现时，既可以实现成固定大小的，也可以是可扩展的，当前主流的虚拟机都是可扩展的（通过-Xmx和-Xms控制）。当在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p><h4 id="1-5方法区"><a href="#1-5方法区" class="headerlink" title="1.5方法区"></a>1.5方法区</h4><p>方法区被<strong>所有线程共享</strong>，用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它有一个别名Non-Heap，目的应该就是与Java堆区分开来。HotSpot虚拟机又把方法区成为“永久代”，本质并不等价，仅仅是因为HotSpot虚拟机选择把GC分代收集扩展至方法区，其他虚拟机不存在永久代的概念。但是更容易遇到内存溢出问题（永久代有-XX:MaxPermSize的上限）而且有极少数方法（String.intern()）会因这个导致不同虚拟机有不同表现。JDK1.7的HotSpot，已经把原本放在永久代的字符串常量池移出。</p><p>在方法区的内存回收目标主要是针对常量池的回收和对类型的卸载。当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p><h4 id="1-6运行时常量池"><a href="#1-6运行时常量池" class="headerlink" title="1.6运行时常量池"></a>1.6运行时常量池</h4><p>运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。Java语音并不要求常量一定只有编译期才能产生，运行期间也可能将新的常量放入池中。这种特性被开发人员利用的比较多的便是String类的intern()方法。当常量池无法再申请到内存时也会抛出OutOfMemoryError异常。</p><h4 id="1-7直接内存"><a href="#1-7直接内存" class="headerlink" title="1.7直接内存"></a>1.7直接内存</h4><p>直接内存并不是虚拟机运行时数据区的一部分，但是这部分内存也被频繁地使用，也可能导致OutOfMemoryError异常。在JDK1.4中新加入了NIO类，引入基于通道与缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，在一些场景中能显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p><p>本机直接内存不会收到Java堆大小的限制，但是受到本机总内存大小以及处理器寻址空间的限制，服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个区域总和大于物理内存的限制，从而导致动态扩展时出现OutOfMemoryError异常。</p><h3 id="2-对象探秘"><a href="#2-对象探秘" class="headerlink" title="2.对象探秘"></a>2.对象探秘</h3><p>以常用的虚拟机HotSpot和常用的内存区域Java堆为例，探秘HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程</p><h4 id="2-1对象的创建"><a href="#2-1对象的创建" class="headerlink" title="2.1对象的创建"></a>2.1对象的创建</h4><div class="note note-info"><p>创建的对象仅限于普通的Java对象，不包括数组和Class对象</p></div><p>当虚拟机遇到一条new指令时，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有那必须先执行相应的类加载的过程。在类加载检查通过后，虚拟机将为对象分配内存，对象所需内存的大小在类加载完成后便可完全确定（2.2对象的内存布局介绍），内存分配方式有“指针碰撞”和“空闲列表”。</p><blockquote><p>指针碰撞：假设Java堆内存绝对规整，使用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，所分配的内存就仅仅是把指针向空闲空间那边移动。<br>空闲列表：如果Java堆内存并不是规整的，虚拟机维护一个列表，记录哪些内存块是可用的，再分配时，从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。</p></blockquote><p>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此，在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。</p><p>除分配算法外，还需要考虑并发情况下的线程安全问题。可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用原来的指针来分配内存的情况。解决这个问题有两种方案，第一种是对分配内存空间的动作进行同步处理——实际上虚拟机采用CSA配上失败重试的方式保证更新操作的原子性；另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）。哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数来设定。</p><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用TLAB，可以TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就能直接使用，程序能访问到这些字段的数据类型对应的零值。接下来，虚拟机对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象头之中。根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。紧接着执行<init>方法，把对象按照程序员的意愿进行初始化操作。</init></p><h4 id="2-2对象的内存布局"><a href="#2-2对象的内存布局" class="headerlink" title="2.2对象的内存布局"></a>2.2对象的内存布局</h4><p>对象在内存中存储的布局分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p><h5 id="2-2-1对象头"><a href="#2-2-1对象头" class="headerlink" title="2.2.1对象头"></a>2.2.1对象头</h5><p>HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，官方称它为“Mark Word”。</p><p>对象在运行时数据很多，超过了32bit和64bit，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽可能多的信息。例如，在32位的HotSpot虚拟机中，如果对象处于未被锁定的状态下，那么Mark Word的25bit用于存储对象哈希码，4bit存储对象分代年龄，2bit存储锁标志位，1bit固定为0，而在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下的存储内容见表</p><table><thead><tr><th align="center">存储内容</th><th align="center">标志位</th><th align="center">状态</th></tr></thead><tbody><tr><td align="center">对象哈希码、对象分代年龄</td><td align="center">01</td><td align="center">未锁定</td></tr><tr><td align="center">指向锁记录的指针</td><td align="center">00</td><td align="center">轻量级锁定</td></tr><tr><td align="center">指向重量级锁的指针</td><td align="center">10</td><td align="center">膨胀（重量级锁定）</td></tr><tr><td align="center">空，不需要记录信息</td><td align="center">11</td><td align="center">GC标记</td></tr><tr><td align="center">偏向线程ID、偏向时间戳、对象分代年龄</td><td align="center">01</td><td align="center">可偏向</td></tr></tbody></table><p>对象头的另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身，这点将在2.3讨论。另外，如果对象是一个Java数组，那么在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中却无法确定数组的大小。</p><h5 id="2-2-2实例数据"><a href="#2-2-2实例数据" class="headerlink" title="2.2.2实例数据"></a>2.2.2实例数据</h5><p>在程序代码中所定义的字段内容，包括父类继承的，都需要记录，这部分的存储顺序受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。HotSpot虚拟机默认的分配策略为longs/doubles、ints、shorts/chars、bytes/boolean、oops（Ordinary Object Pointers），相同宽度的字段总是被分配到一起。在满足这个前提条件，父类的变量会出现在子类之前。如果CompactFields参数值为true（默认为true），那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。</p><h5 id="2-2-3对齐填充"><a href="#2-2-3对齐填充" class="headerlink" title="2.2.3对齐填充"></a>2.2.3对齐填充</h5><p>这部分不是必然存在的，仅仅起着占位符的作用。<strong>由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍</strong>，换句话说就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数，因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h4 id="2-3对象的访问定位"><a href="#2-3对象的访问定位" class="headerlink" title="2.3对象的访问定位"></a>2.3对象的访问定位</h4><p>Java程序需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机实现而定的。目前主流的访问方式有<strong>使用句柄</strong>和<strong>直接指针</strong>两种。</p><h5 id="2-3-1使用句柄"><a href="#2-3-1使用句柄" class="headerlink" title="2.3.1使用句柄"></a>2.3.1使用句柄</h5><p>Java堆中会划分一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。</p><p><img src="/img/article/004_%E9%80%9A%E8%BF%87%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png" srcset="/img/loading.gif" alt=""></p><h5 id="2-3-2直接指针"><a href="#2-3-2直接指针" class="headerlink" title="2.3.2直接指针"></a>2.3.2直接指针</h5><p>如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。</p><p><img src="/img/article/004_%E9%80%9A%E8%BF%87%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png" srcset="/img/loading.gif" alt=""></p><h5 id="2-3-3两者的区别"><a href="#2-3-3两者的区别" class="headerlink" title="2.3.3两者的区别"></a>2.3.3两者的区别</h5><p>两种方式都各有优势，使用句柄来访问最大的好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。<br>使用直接指针访问最大的好处就是速度更快，节省一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。<strong>HotSpot虚拟机使用的是直接指针访问</strong>。</p></article><hr><div><div class="post-metas mb-3"><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p><div class="post-prevnext row"><div class="post-prev col-6"></div><div class="post-next col-6"><a href="/2020/04/29/003_2020-04-29_%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"><span class="hidden-mobile">初试搭建博客</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></div></div></div></div></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div id="tocbot"></div></div></div></div></div></main><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><footer class="mt-5"><div class="text-center py-3"><div><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script><script src="/js/main.js"></script><script src="/js/lazyload.js"></script><script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script><script>$(document).ready(function(){var t=$("#board-ctn").offset().top;tocbot.init({tocSelector:"#tocbot",contentSelector:".post-content",headingSelector:"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:0,scrollSmooth:!0,headingsOffset:-t}),0<$(".toc-list-item").length&&$("#toc").css("visibility","visible")})</script><script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script><script src="/js/clipboard-use.js"></script><script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script><script>var typed=new Typed("#subtitle",{strings:["  ","Java虚拟机——内存区域&nbsp;"],cursorChar:"_",typeSpeed:600,loop:!1});typed.stop(),$(document).ready(function(){$(".typed-cursor").addClass("h2"),typed.start()})</script><script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script><script>anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))</script><script src="/js/local-search.js"></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){getSearchFile(path),this.onclick=null}</script><script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><script>$("#post img:not(.no-zoom img, img[no-zoom]), img[zoom]").each(function(){var t=document.createElement("a");$(t).attr("data-fancybox","images"),$(t).attr("href",$(this).attr("src")),$(this).wrap(t)})</script></body></html>